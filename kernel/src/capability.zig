//! KOZO Kernel - Capability Engine (Layer 0)
//! Responsibility: Memory retyping, minting, transfer, and verification.
//! Security: All operations are capability-gated; no ambient authority.

const std = @import("std");
const abi = @import("kozo_abi.h"); // Generated by build.zig
const thread = @import("thread.zig");
const spinlock = @import("spinlock.zig");

/// Global capability registry lock (short-held, IRQ-disabled sections)
var cap_lock = spinlock.SpinLock{};

/// A CNode (Capability Node) is a table of capability slots.
/// CNodies are the only objects that can contain capabilities.
pub const CNode = struct {
    slots: []CapSlot,
    parent: ?*CNode, // For revocation tracking (DLL)
    next_sibling: ?*CNode,
    prev_sibling: ?*CNode,
    
    pub fn get(self: *CNode, index: usize) !*CapSlot {
        if (index >= self.slots.len) return error.InvalidIndex;
        return &self.slots[index];
    }

    pub fn insert(self: *CNode, index: usize, slot: CapSlot) !void {
        if (index >= self.slots.len) return error.InvalidIndex;
        if (self.slots[index].cap_type != .CAP_NULL) return error.SlotOccupied;
        self.slots[index] = slot;
    }
    
    pub fn remove(self: *CNode, index: usize) !CapSlot {
        if (index >= self.slots.len) return error.InvalidIndex;
        const slot = self.slots[index];
        if (slot.cap_type == .CAP_NULL) return error.NoCap;
        self.slots[index] = NULL_SLOT;
        return slot;
    }
    
    pub fn findFreeSlot(self: *CNode) !usize {
        for (self.slots, 0..) |slot, i| {
            if (slot.cap_type == .CAP_NULL) return i;
        }
        return error.NoFreeSlots;
    }
};

pub const CapSlot = struct {
    cap_type: abi.kozo_cap_type_t,
    rights: abi.kozo_rights_t,
    // Badge: unforgeable kernel-generated ID for this specific capability instance
    // Used by Policy Service to verify capability authenticity
    badge: u64,
    data: union {
        untyped: struct {
            base: usize,   // Physical base address
            size: usize,   // Total size bytes
            offset: usize, // Allocated so far (for splitting)
            parent: ?*CapSlot, // For memory revocation chains
        },
        cnode: struct {
            ptr: *CNode,
        },
        endpoint: struct {
            badge: u64,    // Receiver identifies sender by this
            queue: thread.ThreadQueue, // Blocked senders
        },
        thread: struct {
            tcb: *thread.TCB,
        },
        frame: struct {
            phys: usize,   // Physical page address
            mapped: bool,  // Is currently mapped?
        },
    },
};

const NULL_SLOT = CapSlot{
    .cap_type = .CAP_NULL,
    .rights = 0,
    .badge = 0,
    .data = undefined,
};

/// SYS_RETYPE: Convert Untyped memory into structured Kernel Objects.
/// This is the ONLY way to create new kernel objects after boot.
/// Defense in Depth: Zeroes memory to prevent cross-domain info leaks.
pub fn sys_retype(untyped_idx: usize, new_type: abi.kozo_cap_type_t, 
                  dest_slot: usize, size_bits: usize) isize {
    const irq_state = cap_lock.lock(); // Disable IRQs, acquire lock
    defer cap_lock.unlock(irq_state);
    
    const current = thread.getCurrent();
    const untyped_slot = current.root_cnode.get(untyped_idx) catch return -2; // NoCap
    const untyped_cap = untyped_slot.*;

    if (untyped_cap.cap_type != .CAP_UNTYPED) return -1; // Invalid
    if (untyped_cap.data.untyped.offset >= untyped_cap.data.untyped.size) return -3; // NoMem

    const obj_size = @as(usize, 1) << @intCast(size_bits);
    const remaining = untyped_cap.data.untyped.size - untyped_cap.data.untyped.offset;
    
    if (obj_size > remaining) return -3; // NoMem

    const phys_addr = untyped_cap.data.untyped.base + untyped_cap.data.untyped.offset;
    
    // Defense in Depth: Zero memory to prevent information leakage
    // between security domains (old owner -> new owner)
    const ptr = @as([*]u8, @ptrFromInt(phys_addr));
    @memset(ptr[0..obj_size], 0);

    // Generate unique badge for this capability instance
    const new_badge = generateBadge(phys_addr, new_type);
    
    var new_slot = CapSlot{
        .cap_type = new_type,
        .rights = abi.RIGHT_READ | abi.RIGHT_WRITE | abi.RIGHT_GRANT,
        .badge = new_badge,
        .data = undefined,
    };

    // Type-specific initialization
    switch (new_type) {
        .CAP_CNODE => {
            const cnode_ptr = @as(*CNode, @ptrFromInt(phys_addr));
            cnode_ptr.slots = @as([*]CapSlot, @ptrFromInt(phys_addr + @sizeOf(CNode)))[0..(1 << size_bits)];
            // Zero all slots
            for (cnode_ptr.slots) |*slot| slot.* = NULL_SLOT;
            cnode_ptr.parent = null;
            cnode_ptr.next_sibling = null;
            cnode_ptr.prev_sibling = null;
            new_slot.data = .{ .cnode = .{ .ptr = cnode_ptr } };
        },
        .CAP_ENDPOINT => {
            new_slot.data = .{ .endpoint = .{
                .badge = new_badge,
                .queue = thread.ThreadQueue.init(),
            }};
        },
        .CAP_THREAD => {
            // Thread control block allocated but not yet initialized
            // Thread_create syscall will populate
            new_slot.data = .{ .thread = .{ .tcb = @ptrFromInt(phys_addr) }};
        },
        .CAP_FRAME => {
            new_slot.data = .{ .frame = .{
                .phys = phys_addr,
                .mapped = false,
            }};
        },
        else => return -1, // Invalid type
    }

    // Insert into destination
    current.root_cnode.insert(dest_slot, new_slot) catch return -5; // NoSpace
    
    // Update untyped offset (consume this memory)
    untyped_slot.data.untyped.offset += obj_size;
    
    return 0; // OK
}

/// SYS_CAP_TRANSFER: Move/Copy capability between CNodies (Policy Service use)
/// Policy Service uses this to delegate capabilities to apps after user approval.
pub fn sys_transfer(src_idx: usize, dest_cnode_idx: usize, dest_slot: usize, 
                    new_rights: abi.kozo_rights_t) isize {
    const irq_state = cap_lock.lock();
    defer cap_lock.unlock(irq_state);
    
    const current = thread.getCurrent();
    
    // Verify source capability exists and has GRANT right
    const src_slot = current.root_cnode.get(src_idx) catch return -2;
    if (src_slot.cap_type == .CAP_NULL) return -2;
    if (src_slot.rights & abi.RIGHT_GRANT == 0) return -4; // AccessDenied
    
    // Get destination CNode capability
    const dest_cnode_slot = current.root_cnode.get(dest_cnode_idx) catch return -2;
    if (dest_cnode_slot.cap_type != .CAP_CNODE) return -1; // Invalid
    
    const dest_cnode = dest_cnode_slot.data.cnode.ptr;
    
    // Attenuate rights (cannot grant more than we have)
    const attenuated_rights = new_rights & src_slot.rights;
    
    // Create new slot in destination (copy, not move - for Policy Service flexibility)
    var new_slot = src_slot.*;
    new_slot.rights = attenuated_rights;
    // Badge stays same for verification
    
    dest_cnode.insert(dest_slot, new_slot) catch return -5; // NoSpace
    
    return 0;
}

/// SYS_CAP_MINT: Create attenuated child capability (rights masking)
/// Used by Policy Service to create restricted views (e.g., path-scoped file caps)
pub fn sys_mint(parent_idx: usize, new_rights: abi.kozo_rights_t) isize {
    const irq_state = cap_lock.lock();
    defer cap_lock.unlock(irq_state);
    
    const current = thread.getCurrent();
    const parent_slot = current.root_cnode.get(parent_idx) catch return -2;
    
    // Must have GRANT right to mint children
    if (parent_slot.rights & abi.RIGHT_GRANT == 0) return -4;
    
    // Find free slot in same CNode
    const slot_idx = current.root_cnode.findFreeSlot() catch return -5;
    
    var child = parent_slot.*;
    // Attenuation: child rights subset of parent rights
    child.rights = new_rights & parent_slot.rights;
    // Generate new badge for child to distinguish from parent
    child.badge = generateBadge(@intFromPtr(parent_slot), child.cap_type);
    
    current.root_cnode.insert(slot_idx, child) catch return -1;
    
    return @intCast(slot_idx);
}

/// SYS_CAP_REVOKE: Destroy capability and all derived children
/// Critical for JIT delegation timeout (Policy Service revokes after expiry)
pub fn sys_revoke(cnode_idx: usize, slot_idx: usize) isize {
    const irq_state = cap_lock.lock();
    defer cap_lock.unlock(irq_state);
    
    const current = thread.getCurrent();
    const cnode_slot = current.root_cnode.get(cnode_idx) catch return -2;
    if (cnode_slot.cap_type != .CAP_CNODE) return -1;
    
    const cnode = cnode_slot.data.cnode.ptr;
    const target = cnode.get(slot_idx) catch return -2;
    
    // Recursive revocation for CNodes (destroy all contained caps)
    if (target.cap_type == .CAP_CNODE) {
        revokeCNodeRecursive(target.data.cnode.ptr);
    }
    
    // TODO: For untyped, return memory to pool? (Genesis: just nullify)
    target.* = NULL_SLOT;
    
    return 0;
}

fn revokeCNodeRecursive(cnode: *CNode) void {
    for (cnode.slots) |*slot| {
        if (slot.cap_type == .CAP_CNODE) {
            revokeCNodeRecursive(slot.data.cnode.ptr);
        }
        slot.* = NULL_SLOT;
    }
}

/// SYS_CAP_VERIFY: Verify badge authenticity (Anti-spoofing)
/// Policy Service uses this to confirm AppID matches CNode
pub fn sys_verify(badge: u64, target_handle: usize) isize {
    const irq_state = cap_lock.lock();
    defer cap_lock.unlock(irq_state);
    
    const current = thread.getCurrent();
    const target_slot = current.root_cnode.get(target_handle) catch return -2;
    
    // Verify badge matches the capability's kernel-generated badge
    if (target_slot.badge != badge) return -4; // AccessDenied
    
    return 0;
}

/// Badge Generation: Cryptographically-inspired unique ID
/// Combines physical address, type, and kernel secret to prevent forgery
var badge_counter: u64 = 0;

fn generateBadge(phys: usize, cap_type: abi.kozo_cap_type_t) u64 {
    // Simple hash for genesis block - replace with CSPRNG or TSC in production
    badge_counter += 1;
    const mix = phys ^ @as(usize, @intFromEnum(cap_type)) ^ 0xDEADBEEFCAFEBABE;
    return mix +% badge_counter;
}

// === Syscall Dispatch Table ===
pub const SyscallTable = struct {
    pub fn dispatch(num: usize, arg1: usize, arg2: usize, arg3: usize, arg4: usize) isize {
        return switch (num) {
            abi.SYS_RETYPE => sys_retype(arg1, @enumFromInt(arg2), arg3, arg4),
            abi.SYS_CAP_TRANSFER => sys_transfer(arg1, arg2, arg3, arg4),
            abi.SYS_CAP_MINT => sys_mint(arg1, arg2),
            abi.SYS_CAP_REVOKE => sys_revoke(arg1, arg2),
            abi.SYS_CAP_VERIFY => sys_verify(arg1, arg2),
            else => -1, // Invalid syscall
        };
    }
};