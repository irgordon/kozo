<p align="center">
  <a href="https://kozo.page"><img src="kozo-logo.svg" width="240" alt="KOZO: Made Simple, Designed Secure."></a>
</p>

<p align="center">
  <img src="https://img.shields.io/badge/Built_with-Zig-F7A41D?style=for-the-badge&logo=zig&logoColor=white" />
  <img src="https://img.shields.io/badge/Built_with-Rust-000000?style=for-the-badge&logo=rust&logoColor=%23B7410E" />
  <img src="https://img.shields.io/badge/Platform-KOZO_Native-000000?style=for-the-badge&logo=linux&logoColor=white" />
  <img src="https://img.shields.io/badge/License-FOSS-000000?style=for-the-badge&logo=opensourceinitiative&logoColor=white" />
  <img src="https://img.shields.io/badge/Architectures-x86__64%20%7C%20ARM64-000000?style=for-the-badge" />
</p>

# **KOZO**

**KOZO** is a next-generation operating system built from the ground up for privacy, performance, and peace of mind. By combining the precision of **Zig** with the safety of **Rust**, KOZO creates a computing environment that is "Secure by Default" without sacrificing the apps you love.



## **Why KOZO?**

- **Built-In Privacy**
  In KOZO, your data isn't just "protected"—it's unreachable. Using a **Zero Trust** model, apps only see exactly what you allow them to see. No more hidden tracking, no more "ambient" access to your files.

- **Unmatched Stability**
  By isolating every part of the system (drivers, internet, files) into its own "sandbox," KOZO ensures that a crash in one app never takes down the whole computer. It’s an OS that stays out of your way and just works.

- **Run Your Favorite Apps**
  You don't have to switch your workflow. KOZO features a built-in compatibility layer that allows standard Linux applications to run safely and smoothly, but with enhanced security and privacy controls.

- **Performance Without Compromise**
  We use a "Microkernel" design—keeping the core of the OS tiny and lightning-fast. This means faster boot times, smoother multitasking, and better battery life on laptops.

- **Clear-Name Security**
  We've replaced confusing "permissions" with **Clear-Name** prompts. Instead of cryptic codes, KOZO asks you simple questions: *"Allow the Browser to access your Downloads folder?"* You are always in control.



## **Core Principles**

- **Simple & Modular**
  Every piece of KOZO does one thing and does it well. This makes the system easier to update, harder to break, and simpler to trust.

- **Defense-in-Depth**
  We assume threats exist and build layers of protection around your digital life. If one layer is ever compromised, the others remain locked tight.

- **Modern Foundations**
  Leveraging the latest in systems programming (Zig & Rust), KOZO avoids the "legacy baggage" of 40-year-old operating systems, focusing instead on the needs of today's users.

## **Project Structure**

```markdown
kozo/
├── build.zig                          # Root build system - ABI lockstep, CI pipeline
├── README.md                          # Project overview
├── LICENSE                            # MIT/Apache-2.0 dual license
│
├── kernel/                            # Layer 1: Zig Microkernel
│   ├── build.zig                      # Kernel-specific build config
│   ├── src/
│   │   ├── main.zig                   # Entry point, kernel main
│   │   ├── arch.zig                   # Architecture abstraction
│   │   ├── capability.zig             # CNode operations, retype logic
│   │   ├── ipc.zig                    # IPC_CALL, IPC_REPLY implementation
│   │   ├── memory.zig                 # Untyped memory management
│   │   ├── thread.zig                 # Thread control blocks, context switch
│   │   ├── syscall.zig                # Syscall dispatcher (matches abi.rs)
│   │   ├── boot.zig                   # Boot info frame, Init handoff
│   │   └── debug.zig                  # DEBUG_PUTCHAR, panic handlers
│   │
│   └── arch/
│       └── x86_64/
│           ├── boot.S                 # Entry point, multiboot2, long mode
│           ├── context.S              # Context save/restore (integer regs only)
│           ├── ipc.S                  # IPC direct switch (sys_ipc_call, sys_ipc_reply)
│           ├── trap.S                 # IDT, syscall entry/exit
│           ├── fpu_stubs.S            # #UD handler for SSE instructions
│           ├── panic_handler.S        # Dump to serial for user space collection
│           └── linker.ld              # Higher half linker script (0xffffffff80000000)
│
├── services/                          # Layer 2: Rust User Space
│   ├── Cargo.toml                     # Workspace definition
│   ├── Cargo.lock                     # Reproducible builds
│   │
│   ├── kozo-sys/                      # System call interface (ABI lockstep)
│   │   ├── Cargo.toml
│   │   └── src/
│   │       ├── lib.rs                 # Crate root, re-exports
│   │       ├── abi.rs                 # AUTO-GENERATED by build.zig (DO NOT EDIT)
│   │       ├── syscall.rs             # Safe syscall wrappers
│   │       ├── capability.rs          # Capability handle types
│   │       └── boot_info.rs           # Boot frame parsing
│   │
│   ├── init/                          # Init service (bootstrap)
│   │   ├── Cargo.toml
│   │   └── src/
│   │       ├── main.rs                # Init entry: receive Untyped caps
│   │       ├── memory.rs              # Retype Untyped → CNode/Frame
│   │       ├── cnode.rs               # Root CNode management (4096 slots)
│   │       ├── thread.rs              # Spawn test thread
│   │       └── panic.rs               # Panic handler (no_std)
│   │
│   └── fsd/                           # Filesystem daemon (minimal)
│       ├── Cargo.toml
│       └── src/
│           ├── main.rs                # FSD entry: register endpoint
│           ├── endpoint.rs              # IPC endpoint creation
│           ├── handler.rs               # IPC request handler
│           └── ipc_test.rs              # Reply to Init's test call
│   │
│   └── targets/                       # Custom Rust target specs
│       └── x86_64-kozo-none.json      # -nostdlib, -soft-float, +soft-float
│
├── scripts/                           # Build helpers
│   ├── mkinitrd.sh                    # Create cpio archive (init + fsd)
│   ├── mkimage.sh                     # Create bootable disk image
│   ├── integration-test.sh            # QEMU test runner with JUnit output
│   └── preflight.sh                   # Environment validation
│
├── zig-out/                           # Build artifacts (gitignored)
│   ├── include/
│   │   └── kozo_abi.h                 # Generated C header
│   ├── kozo-kernel                    # Kernel binary
│   ├── kozo-kernel-x86_64.debug       # Debug symbols
│   ├── initrd.cpio                    # Initial RAM disk
│   ├── kozo.img                       # Bootable disk image
│   ├── test-results.xml               # JUnit test output
│   └── crash-report.txt               # Anonymized crash reports (if any)
│
└── docs/
    ├── ARCHITECTURE.md                # System design (SOLID and Single Layer Abstraction principles)
    ├── other .md files
```

*** Critical File Relationships (ABI Lockstep)
```markdown
build.zig (triggers)
    ↓
GenerateAbiStep::make()
    ↓
    ├── kernel/include/kozo_abi.h      # Zig kernel consumes
    └── services/kozo-sys/src/abi.rs   # Rust services consume (via KOZO_ABI_RS env)
```

*** App Build Flow ***
```markdown
zig build ci
    ↓
preflight (check zig, rustc, dirs)
    ↓
generate-abi (lockstep abi.h + abi.rs)
    ↓
    ├── kernel (Zig) → kozo-kernel
    ├── init (Rust) → init binary
    └── fsd (Rust) → fsd binary
    ↓
mkinitrd.sh (init + fsd → initrd.cpio)
    ↓
mkimage.sh (kernel + initrd → kozo.img)
    ↓
qemu-smoke (boot → "Init>" → "IPC_OK: fsd" → PASS)
```

## **Status**

KOZO is currently in early, active development. We are laying the foundations for a stable, public release. Early adopters and developers are encouraged to follow our architectural specs for deep-dive technical details.

## **License**

MIT + Apache 2.0 (dual-licensed)

---
